# 2.1 네트워크 애플리케이션의 원리
네트워크 애플리케이션 개발의 중심은 다른 위치의 종단 시스템에서 동작하고<br/>
네트워크를 통해 서로 통신하는 프로그램을 작성하는 것이다.<br/>

- 네트워크 애플리케이션을 위한 통신은 종단 시스템 간의 애플리케이션 계층에서 발생한다.
<br/>

<p align="center"><img width="400" src="https://github.com/jmKim02/ComputerNetworking_A-Top-Down-Approach/assets/174222202/f3770c05-16ca-4607-8306-06c34250f8ce">

<br/>
<br/>

## 2.1.1 네트워크 애플리케이션의 구조
> 📌 `애플리케이션 구조(application architecture)`는 네트워크 구조와 분명히 다르다는 점을 이해해야 한다.<br/>
<br/>

### 애플리케이션 개발자 관점
- `네트워크 구조(5계층 인터넷 아키텍처)`: 고정되어 있고 해당 애플리케이션에 특정 서비스 집합을 제공
- `애플리케이션 구조`: 개발자가 설계하며, 애플리케이션이 다양한 종단 시스템에서 어떻게 조직되어야 하는 지 알려준다.
  - **클라이언트-서버 구조**
  - **P2P 구조**
<br/>

- `클라이언트-서버 구조(client-server architecture)`
  - `서버(server)`: 항상 동작하고 있는 호스트
  - 서버와 서비스는 `클라이언트(client)`라는 다른 호스트들로부터 서비스 요청을 받는다.
  - 클라이언트 호스트는 가끔 또는 항상 켜져 있을 수 있다.
  - 서버가 `고정 IP 주소`를 갖는다.
  - 때로는 하나의 서버 호스트가 자신의 클라이언트로부터 오는 모든 요청을 다 응답하는 것은 불가능하다.
    - 많은 수의 호스트를 갖춘 `데이터 센터(data center)`가 강력한 가상의 서버를 생성하는 역할로 사용된다.
    - 보통 하나의 데이터 센터는 전력이 공급되고 관리되어야 하는 **10만 개** 정도의 서버를 갖추고 있다.
    - 서비스 제공자들은 데이터센터로부터 데이터를 보내기 위해 상호연결과 대역폭에 합당한 비용을 지불해야 한다. 
<br/>

> e.g.) 클라이언트 호스트에서 실행되는 웹 브라우저에서 웹 서버로 서비스 요청<br/>
> 1. 먼저, 웹 서버가 클라이언트 호스트로부터 객체를 요청 받는다.<br/>
> 2. 웹 서버는 요청된 객체를 클라이언트 호스트로 보내며 응답한다.<br/>
> 💡클라이언트-서버 구조에서 클라이언트는 서로 직접적으로 통신하지 않는다.<br/>
<br/>

<p align="center"><img width="600" src="https://github.com/jmKim02/ComputerNetworking_A-Top-Down-Approach/assets/174222202/b9f180c4-3027-4109-81c0-90de99087d29">

<br/>
<br/>

- `P2P 구조(peer-to-peer)`
  - P2P 구조에서는 항상 켜져 있는 인프라스트럭처 서버에 최소로 의존한다(혹은 전혀 의존하지 않는다).
    - 일반적으로 상당한 서버 인프라스트럭처와 서버 대역폭을 요구하지 않아 비용면에서 효율적이다.
  - 대신 애플리케이션은 `피어(peer)`라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신하게 한다.
    - 피어는 서비스 제공자가 소유하지 않고 사용자들이 제어하는 데스크톱과 랩톱이며 대부분 가정, 대학 등에 위치한다.
  - 가장 주목할 만한 특성은 `자가 확장성(self-scalability)`
    - e.g.) P2P 파일 공유 시스템에서 각 피어들이 파일을 요구함으로써 작업 부하를 만들어내지만<br/>
      각 피어들은 또한 파일을 **다른 피어들에게 분배함으로써** 그 시스템에 서비스 능력을 추가한다.
<br/>

  >💡미래 P2P 애플리케이션들의 경우 고도의 분산 구조 특성으로 보안, 성능, 신뢰성 면에서 커다란 도전을 맞이하고 있다.
<br/>

## 2.1.2 프로세스 통신
네트워크 애플리케이션을 개발하기 전에 여러 종단 시스템에서 실행하는 프로그램이 서로 통신하는 방법을 이해해야 한다.<br/>
운영체제 용어에서 실제 통신하는 것은 **프로그램**이 아닌 `프로세스(procesS)`다.<br/>

### 프로세스(process)
- 프로세스는 종단 시스템에서 실행되는 프로그램
- 통신 프로세스가 같은 종단 시스템에서 실행될 때 그들은 서로 프로세스 간에 통신한다.
- 프로세스 간의 **통신 규칙**은 종단 시스템의 **운영체제**에 의해 좌우된다.
- 2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 `메시지(message)` 교환으로 서로 통신한다.
  - 송신 프로세스는 메시지를 만들어 네트워크로 보내고, 수신 프로세스는 메시를 받고 역으로 보냄으로써 응답
<br/>

### 클라이언트와 서버 프로세스
네트워크 애플리케이션은 네트워크에서 서로 메시를 보내는 두 프로세스로 구성된다.<br/>

- 통신 프로세스 각 쌍에 대해 일반적으로 클라이언트와 서버의 프로세스 중 하나로 이름 짓는다.
  - e.g.) 웹에서 브라우저는 클라이언트 프로세스, 웹 서버는 서버 프로세스
  - e.g.) P2P 파일 공유에서는 파일을 내려받는 피어를 클라이언트, 파일을 올리는 피어를 서버
<br/>

> [!NOTE]
> 클라이언트와 서버는 다음과 같이 정의할 수 있다.<br/>
> - 두 프로세스 간의 통신 세션에서 **통신을 초기화하는 프로세스**를 **클라이언트**라 하고,<br/>
> 세션을 시작하기 위해 **접속을 기다리는 프로세스**를 **서버**라고 한다.<br/>
<br/>

### 프로세스와 컴퓨터 네트워크 사이의 인터페이스
프로세스는 `소켓(socket)`을 통해 네트워크로 메시지를 보내고 받는다.<br/>

- 프로세스는 집(house), 소켓은 출입구(door)로 비유된다.
  - 프로세스가 다른 호스트의 프로세스로 메시지를 보내고 싶을 때, 출입구(소켓) 바깥 네트워크로 메시를 밀어낸다.
  - 아래 그림은 인터넷에서 통신하는 두 프로세스 사이의 소켓 통신을 보여준다.
<br/>

<p align="center"><img width="600" src="https://github.com/jmKim02/ComputerNetworking_A-Top-Down-Approach/assets/174222202/6ca93c13-6e1c-4e64-a94b-8bf4fe5d74ca">

<br/>
<br/>

- `소켓`은 그림에서 보이듯이 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스다.
  - 애플리케이션과 네트워크 사이의 `API(Application Programming Interface)`라고도 한다.
  - 애플리케이션 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만,<br/>
    소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못한다.
  - 트랜스포트 계층에 대한 애플리케이션 개발자의 통제는 아래 2가지 뿐이다.
    - 트랜스포트 프로토콜의 선택(선택이 가능한 경우)
    - 최대 버퍼와 최대 세그먼트 크기와 같은 약간의 트랜스포트 계층 매개변수의 설정
<br/>

### 프로세스 주소 배정
프로세스가 패킷을 다른 호스트의 프로세스로 보내기 위해서는 수신 프로세스가 **주소**를 갖고 있어야 한다.<br/>

- 수신 프로세스를 식별하기 위해서는 두 가지 정보가 명시되어야 한다.
  - 호스트의 주소
  - 그 목적지 호스트 내의 수신 프로세스를 명시하는 식별자
<br/>

- `IP 주소`
  - 인터넷에서 호스트는 **IP 주소**로 식별된다.
  - IP 주소는 32비트로 구성되며, 호스트를 유일하게 식별한다
<br/>

- `포트 번호(port number)`
  - 일반적으로 한 호스트가 많은 네트워크 애플리케이션을 수행하기 때문에 호스트와 더불어 수신 호스트에서<br/>
    수행되고 있는 수신 프로세스(좀 더 자세히는 소켓)도 식별해야 한다. 이 때 **포트 번호**가 사용된다.
  - 인기 있는 애플리케이션은 특정한 포트 번호가 할당된다.
    - e.g.) 웹 서버는 포트 번호 80
    - e.g.) (SMTP 프로토콜을 사용하는) 메일 서버는 포트 번호 25
  > 💡인터넷 표준 프로토콜들의 잘 알려진 포트 번호 목록은 http://www.iana.org 에서 찾아볼 수 있다.
<br/>

## 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스
인터넷을 포함해 많은 네트워크는 하나 이상의 트랜스포트 프로토콜을 제공한다.<br/>
트랜스포트 계층 프로토콜이 그것을 이용하는 애플리케이션들에게 제공할 수 있는 서비스는 무엇인가?<br/>
> 가능한 서비스들을 넓은 범위에서 신뢰적 데이터 전송, 처리율, 시간, 보안이라는 네 가지 차원으로 분류 가능
<br/>

### 신뢰적 데이터 전송(reliable data transfer)
> 📌 프로토콜이 보장된 데이터 전송 서비스를 제공한다면 `신뢰적 데이터 전송`을 제공한다고 한다.
<br/>

트랜스포트 계층 프로토콜이 애플리케이션에 제공할 수 있는 중요한 서비스는 **프로세스 간 신뢰적 데이터 전송**이다.<br/>

- **신뢰적 데이터 전송을 제공할 때**
  - 송신 프로세스는 데이터를 소켓으로 보내고 그 데이터가 **오류 없이** 수신 프로세스에 도착할 것이라는 확신을 갖는다.
- **신뢰적 데이터 전송을 제공하지 않을 때**
  - 송신 프로세스가 보낸 데이터는 수신 프로세스에 전혀 도착하지 않을 수 있다.
  - 이것은 `손실 허용 애플리케이션(loss-tolerant application)`의 경우에는 받아들여질 수 있다.
  > 어느 정도의 데이터 손실을 참아낼 수 있는 실시간 오디오/비디오 같은 멀티미디어 애플리케이션
<br/>

### 처리율
다른 세션들이 네트워크 대역폭을 공유하고, 이 세션들이 생겼다 없어졌다 하기 때문에 가용한 처리율은 시간에 따라 변동한다.<br/>
이러한 관찰로 트랜스포트 프로토콜이 어느 명시된 속도에서 보장된 가용 처리율을 제공한다는 사실을 알 수 있다.<br/>
그러한 서비스로 애플리케이션은 **r비트/초의 보장된 처리율**을 요구할 수 있고, 프로토콜은 가용 처리율이 항상 적어도 r bps임을 보장<br/>

- `대역폭 민감 애플리케이션(bandwidth-sensitive application)`
  - **처리율 요구사항**을 갖는 애플리케이션
  - 어떤 멀티미디어 애플리케이션들은 현재 가용한 처리율에 맞는 속도로 디지털화된 음성 혹은 비디오를 인코딩하는<br/>
    **적응적 코딩 기법**을 사용할 수도 있지만, 현존하는 많은 멀티미디어 애플리케이션은 대역폭에 민감하다.
- `탄력적 애플리케이션(elastic application)`
  - 가용한 처리율을 많으면 많은 대로 적으면 적은 대로 이용할 수 있다.
  - e.g.) 전자메일, 파일 전송, 웹 전송이 융통성 있는 애플리케이션들
  > 물론 대역폭은 많으면 많을수록 좋다.
<br/>

### 시간
> 📌 트랜스포트 계층 프로토콜은 `시간 보장(timing gurantee)`을 제공할 수 있다.
<br/>

처리율 보장과 마찬가지로 시간 보장은 여러 가지 형태로 나타난다.<br/>

- e.g.) 송신자가 소켓으로 내보내는 모든 비트가 수신자의 소켓에 100ms 내에 도착하게 하는 것
  - 인터넷 전화, 가상 환경, 원격회의, 다자간 게임과 같은 실시간 상호작용 애플리케이션에 매력적이다.
  - 이러한 애플리케이션이 효과적으로 동작하기 위해서는 데이터 전송에 **엄격한 시간 제한 조건**이 요구된다.
<br/>

- 비실시간 애플리케이션의 경우 낮은 지연이 항상 높은 지연보다 선호되지만 종단 간 지연에 엄격한 제약을 받는 것은 아니다.
<br/>

### 보안
> 📌 트랜스포토 계층 프로토콜은 애플리케이션에 하나 이상의 `보안 서비스`를 제공할 수 있다.
<br/>

- 트랜스포트 프로토콜은 데이터 송신/수신 과정에서 데이터를 암호화/복호화 할 수 있다.
  - 이러한 서비스는 데이터가 송/수신 프로세스 사이에서 어느 정도 관찰된다 하더라도 두 프로세스 사이에 `기밀성`을 제공
  - 기밀성(confidentiality) 외에도 무결성(integrity), 종단 인증(authentication)등이 포함된다.(자세한 내용은 8장에서)
<br/>

## 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스
인터넷(그리고 일반적인 TCP/IP 네트워크)은 애플리케이션에게 2개의 전송 프로토콜을 제공한다.
- `UDP(User Datagram Protocol)`, `TCP(Transmission Control Protocol)` 두 프로토콜은 각기 다른 서비스 제공
<br/>

### TCP 서비스
TCP 서비스 모델은 **연결지향형 서비스**와 **신뢰적인 데이터 전송 서비스**를 포함한다.<br/>
애플리케이션이 TCP 전송 프로토콜을 사용하면, 애플리케이션은 TCP로부터 이 두 가지 서비스를 받는다.<br/>

- **연결지향형 서비스**
  - 애플리케이션 계층 메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환하게 한다.
    > 이 핸드셰이킹 과정이 클라이언트와 서버에 패킷이 도착하기 전 준비하라고 알려주는 역할
  - 핸드셰이킹 단계를 지나면 TCP 연결이 두 프로세스의 소켓 사이에 존재한다고 말한다.
    > 이 연결은 두 프로세스가 동시에 메시지를 보낼 수 있기에 `전이중(full-duplex)` 연결이라고 한다.
  - 애플리케이션이 메시지 전송을 마치면 연결을 끊어야 한다.
- **신뢰적인 데이터 전송 버스**
  - 통신 프로세스는 모든 데이터를 오류 없이 올바른 순서로 전달하기 위해 TCP에 의존
  - TCP는 한쪽이 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림이 손실되거나 중복되지 않게 수신 소켓으로 전달
<br/>

#### TCP
- TCP는 혼잡 제어 방식, 즉 통신하는 프로세스의 직접 이득보다는 인터넷의 전체 성능 향상을 위한 서비스를 포함
- TCP 혼잡 제어 방식
  - 네트워크가 혼잡 상태에 이르면 프로세스 속도를 낮춘다.
  - 각 TCP 연결이 네트워크 대역폭을 공평하게 공유할 수 있게끔 제한하려고 시도한다.
<br/>

- 아래 그림은 다양한 네트워크 애플리케이션의 요구사항

<p align="center"><img width="600" src="https://github.com/jmKim02/ComputerNetworking_A-Top-Down-Approach/assets/174222202/68b8d848-f5d3-4678-aafe-41972b730c09">

<br/>
<br/>
