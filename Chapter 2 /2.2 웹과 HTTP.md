# 2.2 웹과 HTTP
웹은 `온디맨드` 방식으로 동작하며 사용자는 원할 때 원하는 것을 수신한다.<br/>
개인이 웹상에 어떠한 정보를 사용 가능하게 만드는 것을 포함해 많은 훌륭한 특성이 있다.<br/>

## 2.2.1 HTTP 개요
웹의 애플리케이션 계층 프로토콜인 `HTTP(HyperText Trasnfer Protocol)`는 **웹의 중심**이다.<br/>
HTTP는 두 가지 프로그램으로 구현된다(클라이언트와 서버 프로그램).<br/>
각기 다른 종단 시스템에서 수행되는 클라이언트와 서버 프로그램은 **서로 HTTP 메시지를 교환하여 통신**한다.<br/>
> HTTP는 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 정의하고 있다.
<br/>

### 웹 페이지(Web page)
> `웹 페이지`는 객체들로 구성된다.
<br/>

- `객체(object)`는 단순히 **단일 URL**로 지정할 수 있는 하나의 파일이다.
  > HTML 파일, JPEG 이미지, 자바스크립트 등
- 대부분 웹 페이지는 **기본 HTML 파일**과 여러 참조 객체로 구성된다.
  - e.g.) 웹페이지가 HTML 텍스트와 5개의 JPEG 이미지로 구성<br/>
    -> 이 웹 페이지는 6개의 객체를 갖고 있는 것
  - `기본 HTML 파일`은 페이지 내부의 다른 객체를 그 객체의 URL로 참조한다.
  - 각 URL은 2개의 요소, 즉 객체를 갖고 있는 서버 호스트 이름과 객체의 경로 이름을 갖고 있다.
    - e.g.) http://www.someSchool.edu/someDepartment/picture.gif
    - **호스트 이름**: www.someSchool.edu
    - **경로 이름**: /someDepartment/picture.gif
<br/>

### 웹 브라우저(Web browser)와 웹 서버(Web Server)
`웹 브라우저`: HTTP의 클라이언트 측을 구현하기 때문에 웹의 관점에서 **브라우저와 클라이언트**라는 용어를 혼용하여 사용
- 브라우저는 요구한 웹 페이지를 보여주고 여러 가지 인터넷 항해와 구성 특성을 제공한다.
<br/>

`웹 서버`: HTTP의 서버 측을 구현하는 웹 서버는 URL로 각각을 지정할 수 있는 **웹 객체**를 갖고 있다.
- 인기 있는 웹 서버로 아파치, 마이크로소프트 인터넷 인포메이션 서버 등이 있다.
<br/>

**사용자가 웹 페이지를 요청할 때**
- **브라우저**는 페이지 내부 객체에 대한 HTTP 요청 메시지를 서버에게 보낸다.
- **서버**는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다.
<br/>

<p align="center"><img width="400" src="https://github.com/user-attachments/assets/46fac3f1-4674-4da4-b4fb-0bb071aa770c">

<br/>
<br/>

### HTTP와 TCP
> 💡HTTP는 TCP를 전송 프로토콜로 사용한다.
<br/>

1. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다.
2. 일단 연결이 이뤄지면, 브라우저와 서버 프로세스는 그들의 `소켓 인터페이스`를 통해 TCP로 접속한다.
<br/>

- 앞서 21.절에서 기술한 대로, 소켓 인터페이스는 프로세스와 TCP 연결 사이에서의 출입구 역할을 한다.
- TCP가 HTTP에게 **신뢰적인 데이터 전송 서비스**를 제공한다.
  - 여기서 계층구조의 중요한 점 중 하나를 보게된다.
  - HTTP는 데이터의 손실 또는 TCP가 어떻게 손실 데이터를 구하고 네트워크 내부에서 데이터를 올바른 순서로 배열하는지<br/>
    걱정할 필요가 없다. 이것은 TCP와 프로토콜 하위 계층들이 하는 일
<br/>

#### 비상태 프로토콜(stateless protocol)
> HTTP 서버는 클라이언트에 대한 정보를 유지하지 않으므로 `비상태 프로토콜`이라고 한다.
<br/>

만약 특정 클라이언트가 몇 초 후에 같은 객체를 두 번 요청한다면, <br/>
잠시 전에 이미 그 객체를 보냈다고 알려주면 좋겠지만 서버는 이전 일을 기억하지 않으므로 그 객체를 또 보낸다.<br/>
<br/>

## 2.2.2 비지속 연결과 지속 연결
> 💡HTTP는 비지속 연결과 지속 연결 모두 사용할 수 있다. 디폴트 모드는 지속 연결!
<br/>

### 비지속 연결 HTTP
> 📌 `비지속 연결(non-persistent connection)`은 각 요구/응답 쌍이 **분리된 TCP 연결**을 통해 보내지는 것
<br/>

웹 페이지를 서버에서 클라이언트로 전송하는 단계를 살펴보자.<br/>
페이지가 기본 HTML 파일과 10개의 JPEG 이미지로 구성되고, 이 11개의 객체가 같은 서버에 있다고 가정<br/>
**기본 HTML 파일의 URL**
- http://www.someSchool.edu/someDepartment/home.index
<br/>

**연결 수행 과정**
1. `HTTP 클라이언트`는 HTTP의 기본 **포트 번호 80**을 통해 www.someSchool.edu 서버로 TCP 연결을 시도한다.
   > TCP 연결과 관련하여 클라이언트와 서버에 각각 **소켓**이 있게 된다.
2. `HTTP 클라이언트`는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메시지를 보낸다.
   > 이 요청 메시지는 /someDepartment/home.index 경로로 이름을 포함한다.
3. `HTTP 서버`는 1단계에서 설정된 연결 소켓을 통해 요청 메시지를 받는다. 이후 응답 메시지를 클라이언트로 보낸다.
   > 저장장치로부터 /someDepartment/home.index 객체 추출 및 응답 메시지에 그 객체를 `캡슐화`한다.
4. `HTTP 서버`는 TCP에게 TCP 연결을 끊으라고 한다.
   > 그러나 실제로 TCP 클라이언트가 응답 메시지를 올바로 받을 떄까지 연결을 끊지 않는다.
5. HTTP 클라이언트가 응답 메시지를 받으면, TCP 연결이 중단된다.
   > 메시지는 캡슐화된 객체가 HTML 파일인 것을 나타냄, 이후 파일 추출 및 HTML 파일 조사하고 JPEG 객체에 대한 참조를 찾는다.
6. 그 이후에 참조되는 각 JPEG 객체에 대해 처음 네 단계를 반복한다.
<br/>

> [!NOTE]
> 브라우저는 웹 페이지를 수신하면서 사용자에게 페이지를 보여주며, 다른 브라우저는 웹 페이지를 각기 다른 방식으로 해석하여 보여준다.<br>
> HTTP 명세서는 클라이언트와 서버 사이의 통신 프로토콜만 정의하고, HTTP는 웹 페이지를 어떻게 해석하는지는 관심이 없다.
<br/>

**앞의 연결 수행 과정 정리**
- 앞 단계는 서버가 객체를 보낸 후 각 TCP 연결이 끊어지므로 **비지속 연결**을 사용하고 있다.
  > 각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송한다.
- 사용자가 동시성 정도를 조절할 수 있도록 브라우저를 구성할 수 있다.
  > 동시 연결을 사용하면 응답 시간을 줄일 수 있다.<br/>
  > 브라우저는 여러 개의 TCP 연결을 설정하며 다중 연결상에서 웹 페이지의 각기 다른 부분을 요청할 수도 있다.
<br/>

#### RTT(round-trip-time)
> 📌 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간
<br/>

- `RTT`는 패킷 전파 지연, 패킷 큐잉 지연, 패킷 처리 지연 등을 포함한다.
- 사용자가 하이퍼링크를 클릭하면 `세 방향 핸드셰이크(three-way handshake)`를 포함하여 TCP 연결을 시도한다.
  - 세 방향 핸드셰이크 중 **처음 두 부분**이 경과하면 RTT가 계산된다.
  - 처음 두 과정이 끝난 후에 클라이언트는 HTTP 요청 메시지를 TCP 연결로 보내면서 핸드셰이크의 세 번째 부분(응답)을 함께 보낸다.
- 요청 메시지가 서버에 도착하면 서버는 HTML 파일을 TCP 연결로 보낸다.
  - 이 HTTP 요청/응답은 또 하나의 RTT를 필요로 한다.
<br/>

> 결과적으로 대략 총 응답 시간은 **2RTT와 HTML 파일을 서버가 전송하는 데 걸리는 시간을 더한 것**
<br/>

<p align="center"><img width="400" src="https://github.com/user-attachments/assets/be0146fc-3095-4ee5-ba4c-20ecb8bf987d">

<br/>
<br/>

### 비지속 연결의 단점
- 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다.
  > TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 한다.
- 각 객체는 2 RTT를 필요로 한다.
  > TCP 연결 설정에 1 RTT, 객체를 요청하고 받는 데 1 RTT
<br/>

### 지속 연결 HTTP
> 📌 `지속 연결(persistent connection)`은 모든 요구와 해당하는 응답들이 **같은 TCP 연결**상으로 보내지는 것
<br/>

HTTP/1.1 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다.<br/>
같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다.<br/>
- 전체 웹 페이지(앞 예시의 기본 HTML 파일 + 10개의 JPEG 파일 같은 구성)를 하나의 지속 TCP 연결을 통해 보낼 수 있다.
- 또한 같은 서버에 있는 여러 웹페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있다.
- 이들 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들 수 있다. (파이프라이닝, pipelining)
- 일반적으로 HTTP 서버는 일정 기간(타임아웃 기간) 사용되지 않으면 연결을 닫는다.
<br/>

> 💡 HTTP의 디폴트 모드는 파이프라이닝을 이용한 지속 연결을 사용한다.
<br/>

## 2.2.3 HTTP 메시지 포맷
> HTTP 명세서는 HTTP 메시지 포맷을 정의한다.
<br/>

### HTTP 요청 메시지
다음은 전형적인 HTTP 요청 메시지다.

```
GET /somedir/page.html HTTP/1.1
Host: www.someSchool.edu
Connection: close
User-aget: Mozilla/5.0
Accept-language: fr
```

간단한 요청 메시지만 한 번 분석해보자.
- 메시지가 일반 ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다.
- 메시지가 다섯 줄로 되어 있고 각 줄은 CR(carriage reture)과 LF(line feed)로 구별된다.
- 마지막 줄에 이어서 추가 CR과 LF가 따른다.
<br/>

HTTP 요청 메시지의 첫 줄은 `요청 라인(request line)`이라 부르며, 이후의 줄들은 `헤더 라인(header line)`이라고 부른다.<br/>

### 요청 라인
- 방식(method) 필드
  - **GET, POST, HEAD, PUT, DELETE**를 포함하는 여러 가지 값을 가질 수 있다.
  - HTTP 메시지 대부분은 GET 방식을 사용하며 `GET 방식`은 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용된다.
- URL 필드
- HTTP 버전 필드
<br/>

### 헤더 라인
- 헤더라인 Host: www.someSchool.edu는 객체가 존재하는 호스트를 명시
- 호스트 헤더 라인이 제공하는 정보는 웹 프록시 캐시에서 필요로 한다.
- Connection: close 헤더 라인을 포함함으로써, 브라우저는 서버에게 **지속 연결 사용을 원하지 않는다는 것을 말하고 있다.**
- User-aget: Mozilla/5.0 헤더 라인은 사용자 에이전트, 즉 서버에게 요청을 하는 브라우저 타입을 명시하고 있다.
- Accept-language: fr 헤더는 사용자가 객체의 프랑스어 버전을 원하고 있음을 나타내며 이것이 존재하지 않으면 서버는 기본 버전을 보낸다.
<br/>
  
- HTTP 요청 메시지의 일반 포맷

<p align="center"><img width="600" src="https://github.com/user-attachments/assets/9672e45d-85c0-47b2-9b19-e8313f04ad3c">

<br/>
<br/>

### 개체 몸체(entitiy body)
- GET 방식에서는 비어 있고 POST 방식에서 사용된다.
- 방식 필드의 값이 POST이면, `개체 몸체는` 사용자가 폼 필드에 입력한 것을 포함한다.
  > HTTP 클라이언트는 사용자가 폼을 채워 넣을 때 POST 방식을 사용한다.
<br/>

> [!CAUTION]
> 폼으로 생성한 요구가 반드시 POST 방식을 사용할 필요는 없다.<br/>
> HTML 폼은 흔히 GET 방식을 사용하고 요청된 URL의 입력 데이터를 전송한다.<br/>
> - 폼에 GET 방식을 사용하고 2개의 필드를 가지는 예시
>   - 두 필드의 입력값은 monkeys, bananas
>   - URL은 www.somesite.com/animalsearch?monkeys&bananas
<br/>

### 방식 필드 활용
- `HEAD 방식`은 GET 방식과 유사하다.
  - 서버가 HEAD 방식을 가진 요청을 받으면 HTTP 메시지로 응답, 요청 객체는 보내지 않는다.
  - 애플리케이션 개발자는 흔히 **디버깅**을 위해 HEAD 방식을 사용
- `PUT 방식`은 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용된다.
- `DELETE 방식`은 사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용한다.
<br/>

### HTTP 응답 메시지
다은은 전형적인 HTTP 응답 메시지를 보여주고 있다.

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html 
(data data data data data ...)
```

이 응답 메시지를 주의 깊게 살펴보자.
- 3개의 섹션, 즉 초기 상태 라인(status line), 6개의 헤더 라인, 개체 몸체로 이루어졌다.
- `상태 라인`은 3개의 필드, 즉 **프로토콜 버전 필드, 상태 코드, 해당 상태 메시지**를 갖는다.
  > 이 예에서 서버가 HTTP/1.1을 사용하고 있고, 모든 것이 양호함(OK)을 나타낸다.
- `개체 몸체`는 요청 객체(data data data data data ...)를 포함한다.
<br/>

### 헤더 라인
1. Connection: close: 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫는 데 사용한다.
2. Date: HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다.
   > 💡이 시간이 객체가 생성되거나 마지막으로 수정된 시간을 의미하는 것은 아니다.<br/>
   > 💡서버가 파일 시스템으로부터 객체를 추출하고 응답 메시지에 그 객체를 삽입하여 응답 메시지를 보낸 시간 의미
3. Server: 메시지가 아파치 웹 서버에 의해 만들어졌음을 나타낸다.
   > HTTP 요청 메시지의 User-agent: 헤더 라인과 비슷하다.
4. Last-Modified: 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다.
   > 💡이 헤더는 객체를 로컬 클라이언트와 네트워크 캐시 서버 캐싱에 매우 중요하다.
5. content-Length: 송신되는 객체의 바이트 수
6. Content-Type: 객체 몸체 내부의 객체가 HTML 텍스트인 것을 나타낸다.
<br/>
  
- HTTP 응답 메시지의 일반 포맷

<p align="center"><img width="600" src="https://github.com/user-attachments/assets/2ab3c8e7-2e7e-416f-9995-1d475cdc4a2a">

<br/>
<br/>

### 상태 코드
상태 코드와 연관 문장은 요청 결과를 나타낸다.
- 200 OK: 요청이 성공했고, 정보가 응답으로 보내졌다.
- 301 Moved Permanently: 요청 객체가 영원히 이동되었다. 새로운 URL은 응답 메시지의 Location: 헤더에 나와있다.
- 400 Bad Request: 서버가 요청을 이해할 수 없다는 일반 오류 코드
- 404 Not Found: 요청한 문서가 서버에 존재하지 않는다.
- 505 HTTP Version Not Supported: 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.
<br/>

> 브라우저는 브라우저 타입과 브라우저에 대한 사용자 설정, 그리고 브라우저가 현재 객체를 캐싱하고 있는가에 따라<br/>
> 헤더 라인을 생성한다. 웹 서버도 비슷하게 동장한다.
<br/>

## 2.2.4 사용자와 서버 간의 상호작용: 쿠키
