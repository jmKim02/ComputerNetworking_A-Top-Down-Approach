# 2.2 웹과 HTTP
웹은 `온디맨드` 방식으로 동작하며 사용자는 원할 때 원하는 것을 수신한다.<br/>
개인이 웹상에 어떠한 정보를 사용 가능하게 만드는 것을 포함해 많은 훌륭한 특성이 있다.<br/>

## 2.2.1 HTTP 개요
웹의 애플리케이션 계층 프로토콜인 `HTTP(HyperText Trasnfer Protocol)`는 **웹의 중심**이다.<br/>
HTTP는 두 가지 프로그램으로 구현된다(클라이언트와 서버 프로그램).<br/>
각기 다른 종단 시스템에서 수행되는 클라이언트와 서버 프로그램은 **서로 HTTP 메시지를 교환하여 통신**한다.<br/>
> HTTP는 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 정의하고 있다.
<br/>

### 웹 페이지(Web page)
> `웹 페이지`는 객체들로 구성된다.
<br/>

- `객체(object)`는 단순히 **단일 URL**로 지정할 수 있는 하나의 파일이다.
  > HTML 파일, JPEG 이미지, 자바스크립트 등
- 대부분 웹 페이지는 **기본 HTML 파일**과 여러 참조 객체로 구성된다.
  - e.g.) 웹페이지가 HTML 텍스트와 5개의 JPEG 이미지로 구성<br/>
    -> 이 웹 페이지는 6개의 객체를 갖고 있는 것
  - `기본 HTML 파일`은 페이지 내부의 다른 객체를 그 객체의 URL로 참조한다.
  - 각 URL은 2개의 요소, 즉 객체를 갖고 있는 서버 호스트 이름과 객체의 경로 이름을 갖고 있다.
    - e.g.) http://www.someSchool.edu/someDepartment/picture.gif
    - **호스트 이름**: www.someSchool.edu
    - **경로 이름**: /someDepartment/picture.gif
<br/>

### 웹 브라우저(Web browser)와 웹 서버(Web Server)
`웹 브라우저`: HTTP의 클라이언트 측을 구현하기 때문에 웹의 관점에서 **브라우저와 클라이언트**라는 용어를 혼용하여 사용
- 브라우저는 요구한 웹 페이지를 보여주고 여러 가지 인터넷 항해와 구성 특성을 제공한다.
<br/>

`웹 서버`: HTTP의 서버 측을 구현하는 웹 서버는 URL로 각각을 지정할 수 있는 **웹 객체**를 갖고 있다.
- 인기 있는 웹 서버로 아파치, 마이크로소프트 인터넷 인포메이션 서버 등이 있다.
<br/>

**사용자가 웹 페이지를 요청할 때**
- **브라우저**는 페이지 내부 객체에 대한 HTTP 요청 메시지를 서버에게 보낸다.
- **서버**는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다.
<br/>

<p align="center"><img width="400" src="https://github.com/user-attachments/assets/46fac3f1-4674-4da4-b4fb-0bb071aa770c">

<br/>
<br/>

### HTTP와 TCP
> 💡HTTP는 TCP를 전송 프로토콜로 사용한다.
<br/>

1. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다.
2. 일단 연결이 이뤄지면, 브라우저와 서버 프로세스는 그들의 `소켓 인터페이스`를 통해 TCP로 접속한다.
<br/>

- 앞서 21.절에서 기술한 대로, 소켓 인터페이스는 프로세스와 TCP 연결 사이에서의 출입구 역할을 한다.
- TCP가 HTTP에게 **신뢰적인 데이터 전송 서비스**를 제공한다.
  - 여기서 계층구조의 중요한 점 중 하나를 보게된다.
  - HTTP는 데이터의 손실 또는 TCP가 어떻게 손실 데이터를 구하고 네트워크 내부에서 데이터를 올바른 순서로 배열하는지<br/>
    걱정할 필요가 없다. 이것은 TCP와 프로토콜 하위 계층들이 하는 일
<br/>

#### 비상태 프로토콜(stateless protocol)
> HTTP 서버는 클라이언트에 대한 정보를 유지하지 않으므로 `비상태 프로토콜`이라고 한다.
<br/>

만약 특정 클라이언트가 몇 초 후에 같은 객체를 두 번 요청한다면, <br/>
잠시 전에 이미 그 객체를 보냈다고 알려주면 좋겠지만 서버는 이전 일을 기억하지 않으므로 그 객체를 또 보낸다.<br/>
<br/>

## 2.2.2 비지속 연결과 지속 연결
> 💡HTTP는 비지속 연결과 지속 연결 모두 사용할 수 있다. 디폴트 모드는 지속 연결!
<br/>

### 비지속 연결 HTTP
> 📌 `비지속 연결(non-persistent connection)`은 각 요구/응답 쌍이 **분리된 TCP 연결**을 통해 보내지는 것
<br/>

웹 페이지를 서버에서 클라이언트로 전송하는 단계를 살펴보자.<br/>
페이지가 기본 HTML 파일과 10개의 JPEG 이미지로 구성되고, 이 11개의 객체가 같은 서버에 있다고 가정<br/>
**기본 HTML 파일의 URL**
- http://www.someSchool.edu/someDepartment/home.index
<br/>

**연결 수행 과정**
1. `HTTP 클라이언트`는 HTTP의 기본 **포트 번호 80**을 통해 www.someSchool.edu 서버로 TCP 연결을 시도한다.
   > TCP 연결과 관련하여 클라이언트와 서버에 각각 **소켓**이 있게 된다.
2. `HTTP 클라이언트`는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메시지를 보낸다.
   > 이 요청 메시지는 /someDepartment/home.index 경로로 이름을 포함한다.
3. `HTTP 서버`는 1단계에서 설정된 연결 소켓을 통해 요청 메시지를 받는다. 이후 응답 메시지를 클라이언트로 보낸다.
   > 저장장치로부터 /someDepartment/home.index 객체 추출 및 응답 메시지에 그 객체를 `캡슐화`한다.
4. `HTTP 서버`는 TCP에게 TCP 연결을 끊으라고 한다.
   > 그러나 실제로 TCP 클라이언트가 응답 메시지를 올바로 받을 떄까지 연결을 끊지 않는다.
5. HTTP 클라이언트가 응답 메시지를 받으면, TCP 연결이 중단된다.
   > 메시지는 캡슐화된 객체가 HTML 파일인 것을 나타냄, 이후 파일 추출 및 HTML 파일 조사하고 JPEG 객체에 대한 참조를 찾는다.
6. 그 이후에 참조되는 각 JPEG 객체에 대해 처음 네 단계를 반복한다.
<br/>

> [!NOTE]
> 브라우저는 웹 페이지를 수신하면서 사용자에게 페이지를 보여주며, 다른 브라우저는 웹 페이지를 각기 다른 방식으로 해석하여 보여준다.<br>
> HTTP 명세서는 클라이언트와 서버 사이의 통신 프로토콜만 정의하고, HTTP는 웹 페이지를 어떻게 해석하는지는 관심이 없다.
<br/>

**앞의 연결 수행 과정 정리**
- 앞 단계는 서버가 객체를 보낸 후 각 TCP 연결이 끊어지므로 **비지속 연결**을 사용하고 있다.
  > 각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송한다.
- 사용자가 동시성 정도를 조절할 수 있도록 브라우저를 구성할 수 있다.
  > 동시 연결을 사용하면 응답 시간을 줄일 수 있다.<br/>
  > 브라우저는 여러 개의 TCP 연결을 설정하며 다중 연결상에서 웹 페이지의 각기 다른 부분을 요청할 수도 있다.
<br/>

#### RTT(round-trip-time)
> 📌 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간
<br/>

- `RTT`는 패킷 전파 지연, 패킷 큐잉 지연, 패킷 처리 지연 등을 포함한다.
- 사용자가 하이퍼링크를 클릭하면 `세 방향 핸드셰이크(three-way handshake)`를 포함하여 TCP 연결을 시도한다.
  - 세 방향 핸드셰이크 중 **처음 두 부분**이 경과하면 RTT가 계산된다.
  - 처음 두 과정이 끝난 후에 클라이언트는 HTTP 요청 메시지를 TCP 연결로 보내면서 핸드셰이크의 세 번째 부분(응답)을 함께 보낸다.
- 요청 메시지가 서버에 도착하면 서버는 HTML 파일을 TCP 연결로 보낸다.
  - 이 HTTP 요청/응답은 또 하나의 RTT를 필요로 한다.
<br/>

> 결과적으로 대략 총 응답 시간은 **2RTT와 HTML 파일을 서버가 전송하는 데 걸리는 시간을 더한 것**
<br/>

<p align="center"><img width="400" src="https://github.com/user-attachments/assets/be0146fc-3095-4ee5-ba4c-20ecb8bf987d">

<br/>
<br/>

### 비지속 연결의 단점
- 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다.
  > TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 한다.
- 각 객체는 2 RTT를 필요로 한다.
  > TCP 연결 설정에 1 RTT, 객체를 요청하고 받는 데 1 RTT
<br/>

### 지속 연결 HTTP
> 📌 `지속 연결(persistent connection)`은 모든 요구와 해당하는 응답들이 **같은 TCP 연결**상으로 보내지는 것
<br/>

HTTP/1.1 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다.<br/>
같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다.<br/>
- 전체 웹 페이지(앞 예시의 기본 HTML 파일 + 10개의 JPEG 파일 같은 구성)를 하나의 지속 TCP 연결을 통해 보낼 수 있다.
- 또한 같은 서버에 있는 여러 웹페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있다.
- 이들 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들 수 있다. (파이프라이닝, pipelining)
- 일반적으로 HTTP 서버는 일정 기간(타임아웃 기간) 사용되지 않으면 연결을 닫는다.
<br/>

> 💡 HTTP의 디폴트 모드는 파이프라이닝을 이용한 지속 연결을 사용한다.
<br/>

## 2.2.3 HTTP 메시지 포맷
> HTTP 명세서는 HTTP 메시지 포맷을 정의한다.
<br/>

### HTTP 요청 메시지
다음은 전형적인 HTTP 요청 메시지다.

```
GET /somedir/page.html HTTP/1.1
Host: www.someSchool.edu
Connection: close
User-aget: Mozilla/5.0
Accept-language: fr
```

간단한 요청 메시지만 한 번 분석해보자.
- 메시지가 일반 ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다.
- 메시지가 다섯 줄로 되어 있고 각 줄은 CR(carriage reture)과 LF(line feed)로 구별된다.
- 마지막 줄에 이어서 추가 CR과 LF가 따른다.
<br/>

HTTP 요청 메시지의 첫 줄은 `요청 라인(request line)`이라 부르며, 이후의 줄들은 `헤더 라인(header line)`이라고 부른다.<br/>

### 요청 라인
- 방식(method) 필드
  - **GET, POST, HEAD, PUT, DELETE**를 포함하는 여러 가지 값을 가질 수 있다.
  - HTTP 메시지 대부분은 GET 방식을 사용하며 `GET 방식`은 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용된다.
- URL 필드
- HTTP 버전 필드
<br/>

### 헤더 라인
- 헤더라인 Host: www.someSchool.edu는 객체가 존재하는 호스트를 명시
- 호스트 헤더 라인이 제공하는 정보는 웹 프록시 캐시에서 필요로 한다.
- Connection: close 헤더 라인을 포함함으로써, 브라우저는 서버에게 **지속 연결 사용을 원하지 않는다는 것을 말하고 있다.**
- User-aget: Mozilla/5.0 헤더 라인은 사용자 에이전트, 즉 서버에게 요청을 하는 브라우저 타입을 명시하고 있다.
- Accept-language: fr 헤더는 사용자가 객체의 프랑스어 버전을 원하고 있음을 나타내며 이것이 존재하지 않으면 서버는 기본 버전을 보낸다.
<br/>
  
- HTTP 요청 메시지의 일반 포맷

<p align="center"><img width="600" src="https://github.com/user-attachments/assets/9672e45d-85c0-47b2-9b19-e8313f04ad3c">

<br/>
<br/>

### 개체 몸체(entitiy body)
- GET 방식에서는 비어 있고 POST 방식에서 사용된다.
- 방식 필드의 값이 POST이면, `개체 몸체는` 사용자가 폼 필드에 입력한 것을 포함한다.
  > HTTP 클라이언트는 사용자가 폼을 채워 넣을 때 POST 방식을 사용한다.
<br/>

> [!CAUTION]
> 폼으로 생성한 요구가 반드시 POST 방식을 사용할 필요는 없다.<br/>
> HTML 폼은 흔히 GET 방식을 사용하고 요청된 URL의 입력 데이터를 전송한다.<br/>
> - 폼에 GET 방식을 사용하고 2개의 필드를 가지는 예시
>   - 두 필드의 입력값은 monkeys, bananas
>   - URL은 www.somesite.com/animalsearch?monkeys&bananas
<br/>

### 방식 필드 활용
- `HEAD 방식`은 GET 방식과 유사하다.
  - 서버가 HEAD 방식을 가진 요청을 받으면 HTTP 메시지로 응답, 요청 객체는 보내지 않는다.
  - 애플리케이션 개발자는 흔히 **디버깅**을 위해 HEAD 방식을 사용
- `PUT 방식`은 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용된다.
- `DELETE 방식`은 사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용한다.
<br/>

### HTTP 응답 메시지
다은은 전형적인 HTTP 응답 메시지를 보여주고 있다.

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html 
(data data data data data ...)
```

이 응답 메시지를 주의 깊게 살펴보자.
- 3개의 섹션, 즉 초기 상태 라인(status line), 6개의 헤더 라인, 개체 몸체로 이루어졌다.
- `상태 라인`은 3개의 필드, 즉 **프로토콜 버전 필드, 상태 코드, 해당 상태 메시지**를 갖는다.
  > 이 예에서 서버가 HTTP/1.1을 사용하고 있고, 모든 것이 양호함(OK)을 나타낸다.
- `개체 몸체`는 요청 객체(data data data data data ...)를 포함한다.
<br/>

### 헤더 라인
1. Connection: close: 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫는 데 사용한다.
2. Date: HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다.
   > 💡이 시간이 객체가 생성되거나 마지막으로 수정된 시간을 의미하는 것은 아니다.<br/>
   > 💡서버가 파일 시스템으로부터 객체를 추출하고 응답 메시지에 그 객체를 삽입하여 응답 메시지를 보낸 시간 의미
3. Server: 메시지가 아파치 웹 서버에 의해 만들어졌음을 나타낸다.
   > HTTP 요청 메시지의 User-agent: 헤더 라인과 비슷하다.
4. Last-Modified: 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다.
   > 💡이 헤더는 객체를 로컬 클라이언트와 네트워크 캐시 서버 캐싱에 매우 중요하다.
5. content-Length: 송신되는 객체의 바이트 수
6. Content-Type: 객체 몸체 내부의 객체가 HTML 텍스트인 것을 나타낸다.
<br/>
  
- HTTP 응답 메시지의 일반 포맷

<p align="center"><img width="600" src="https://github.com/user-attachments/assets/2ab3c8e7-2e7e-416f-9995-1d475cdc4a2a">

<br/>
<br/>

### 상태 코드
상태 코드와 연관 문장은 요청 결과를 나타낸다.
- 200 OK: 요청이 성공했고, 정보가 응답으로 보내졌다.
- 301 Moved Permanently: 요청 객체가 영원히 이동되었다. 새로운 URL은 응답 메시지의 Location: 헤더에 나와있다.
- 400 Bad Request: 서버가 요청을 이해할 수 없다는 일반 오류 코드
- 404 Not Found: 요청한 문서가 서버에 존재하지 않는다.
- 505 HTTP Version Not Supported: 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.
<br/>

> 브라우저는 브라우저 타입과 브라우저에 대한 사용자 설정, 그리고 브라우저가 현재 객체를 캐싱하고 있는가에 따라<br/>
> 헤더 라인을 생성한다. 웹 서버도 비슷하게 동장한다.
<br/>

## 2.2.4 사용자와 서버 간의 상호작용: 쿠키
앞서 HTTP 서버는 상태를 유지하지 않는다고 했다. 그러나 서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기 원하므로<br/>
사용자를 확인하는 것이 바람직할 때가 있는데, 이 목적으로 HTTP는 `쿠키(cookie)`를 사용한다.<br/>

### 쿠키(cookie)
대부분의 주요 상용 웹사이트는 쿠키를 사용하고 있다.<br/>
쿠키 기술은 네 가지 요소를 갖는다.
1. HTTP 응답 메시지 쿠키 헤더 라인
2. HTTP 요청 메시지 쿠키 헤더 라인
3. 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
4. 웹사이트의 백엔드 데이터베이스
<br/>

### 쿠키의 동작 과정
> 가정: 이미 과거에 사이트를 방문한 적이 있다.
<br/>

1. 클라이언트는 웹 서버에 HTTP 요청 메시지를 전달한다.
2. 웹 서버는 유일한 식별 번호를 만들고 이 식별 번호로 인덱싱 되는 백엔드 데이터 베이스 안에 엔트리를 만든다.
3. 웹 서버는 HTTP 응답 메시지에 식별번호를 담고 있는 Set-cookie: 헤더를 포함해서 전달한다.
4. 브라우저는 그 Set-cookie: 헤더를 보고, 관리하는 특정한 쿠키 파일에 그 라인을 덧붙인다.
5. 이후 동일 웹 서버에 요청을 보낼 때, 브라우저는 쿠키 파일을 참조하고 이 사이트에 대한 식별번호를 발췌하여<br/>
   HTTP 요청에 식별번호를 포함하는 쿠키 헤더파일을 넣는다.
<br/>
  
- 쿠키를 이용한 사용자 상태 유지

<p align="center"><img width="600" src="https://github.com/user-attachments/assets/381ab992-9dde-4fb8-ba02-a1d0fc44a4dc">

<br/>
<br/>

> 위 논의로부터 쿠키는 사용자 식별에 사용함을 알 수 있다.<br/>
> 쿠키는 비상태 HTTP 위에서 사용자 세션 계층을 생성하는 데 이용될 수 있다.
<br/>

## 2.2.5 웹 캐싱
`웹 캐시(Web cache, 프록시 서버(proxy server) 라고도 함)`는 기점 웹 서버를 대신하여 HTTP 요구를 충족시키는 네트워크 개체<br/>
웹 캐시는 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다.<br/>
<br/>

### 프록시 서버 동작 과정
브라우저는 사용자의 모든 HTTP 요구가 웹 캐시에 가장 먼저 보내지도록 구성될 수 있다.<br>
예를 들어, http://www.someSchool.edu/campus.gif라는 객체를 요구하는 상황을 보자.<br/>

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 사본이 저장되어 있는지 확인하고, 저장되어 있다면 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.
3. 객체를 갖고 있지 않다면, 기점 서버인 www.someSchool.edu로 TCP 연결을 설정한다.<br/>
   이후 웹 캐시는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보내고, 기점 서버는 웹 캐시로 HTTP 응답 메시지를 보낸다.
4. 웹 캐시의 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체 사본을 보낸다.
   > 이 때, 클라이언트 브라우저와 웹 캐시 사이에 이미 설정된 TCP 연결을 통해 보낸다.
<br/
  
- 웹 캐시를 통한 클라이언트의 객체 요청

<p align="center"><img width="600" src="https://github.com/user-attachments/assets/fea32e2d-9480-44a5-8729-c60a7138f08f">

<br/>
<br/>

> 💡캐시는 서버이면서 클라이언트이고, 일반적으로 웹 캐시는 ISP가 구입하고 설치한다.
<br/>

### 웹 캐싱의 사용 이유
1. 웹 캐시는 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다.
   - 특히 클라이언트와 기점 서버 사이의 병목 대역폭이 클라이언트와 캐시 사이의 병목 대역폭에 비해 매우 작을 때 더욱 효과적
2. 웹 캐시는 한 기관에서 인터넷으로의 접속하는 링크상의 웹 트래픽을 대폭으로 줄일 수 있다.
   - 트래픽을 줄여주면, 기관은 자주 대역폭을 개선할 필요가 없어져 비용을 줄일 수 있다.
3. 웹 캐시는 인터넷 전체의 웹 트래픽을 실질적으로 줄임으로써 모든 애플리케이션을 위한 성능을 개선한다.
<br/>

### 캐시의 장점 예시
- 아래 그림에서 기관 네트워크는 `고속 LAN`이며 기관 네트워크에 있는 라우터와 인터넷에 있는 라우터는 15 Mbps 회선에 연결
- **가정**
  - 평균 객체 크기가 **1 Mb**, 기관 브라우저로부터 기점 서버에 대한 평균 요청 비율이 **초당 15요청**
  - HTTP 메시지 요청이 무시할 만큼 작으므로 네트워크나 접속 회선에 어떤 트래픽도 발생시키지 않는다.
  - 접속 회선의 인터넷 부분 라우터가 HTTP 요청을 전달하고 응답을 받을 때까지 평균 소요 시간은 **2초**, 통상 `인터넷 지연`이라 한다.
<br/>
  
- 기관 네트워크와 인터넷 간의 병목 현상

<p align="center"><img width="400" src="https://github.com/user-attachments/assets/91b07d94-c1b9-4d22-bc3d-656ed79757fa">

<br/>
<br/>

- `총 응답 시간(브라우저의 요청으로부터 객체 수신까지 걸리는 시간)`: LAN 지연 + 접속 지연 + 인터넷 지연
  - **LAN**의 트래픽 강도 대략적인 계산: (15요청/초) * (1 Mb/요청) / (100 Mbps) = 0.15
  - **접속 회선**의 트래픽 강도 대략적인 계산: (15요청/초) * (1 Mb/요청) / (15 Mbps) = 1
  - 1.4.2절에서 언급했던 것처럼 **트래픽 강도가 1에 가까워지면** 지연이 매우 커지고 한없이 증가해 기관 사용자에게 적합하지 않다.
<br/>

이것은 분명히 해결되어야 하는데, 한 가지 가능한 방법은 접속률을 15 Mbps에서 100 Mbps로 늘리는 것이다.<br/>
-> 접속 회선의 트래픽 강도가 0.15 수준까지 낮춰진다. 이 경우, 총 응답 지연은 대략 2초
> 단, 이 경우 접속 회선을 100 Mbps로 개선해야 하므로 많은 비용의 문제가 남아있다.
<br/>

그렇다면 다른 해결 방법으로, 기관 네트워크에 웹 캐시를 설치하는 방법이 있다.<br/>
`적중률(캐시가 만족시킨 요청 비율)`은 일반적으로 0.2 ~ 0.7이다.<br/>
여기서는 캐시가 0.4의 적중률을 제공한다고 가정하자
<br/>
  
- 기관 네트워크에 캐시 추가

<p align="center"><img width="400" src="https://github.com/user-attachments/assets/7f1c85f9-9188-4ced-9542-1506fc15de79">

<br/>
<br/>

- 캐시와 클라이언트가 고속 LAN으로 연결되어 있으므로 요청의 40%는 즉시(10 ms 이내) 만족된다.
- 요청된 객체의 60%만 접속 회선을 통과하므로 트래픽 강도는 1.0 -> 0.6 감소
  > 일반적으로 트래픽 강도 0.8 미만의 트래픽 강도는 작은 지연(15 Mbps 회선에서 수십 ms 정도)에 속한다.
- 결과적으로 이들을 고려한 평균 지연: 0.4 * (0.01초) + 0.6 * (2.01)초 = 1.2초를 조금 넘는 지연
<br>

```
두 번째 해결방법은 첫 번째 방법보다 낮은 응답 시간을 가지며 기관이 인터넷을 위한 회선을 증설할 필요가 없다.
물론 기관은 웹 캐시를 구입하고 설치해야 하지만, 캐시 가격은 저렴하고 많은 캐시가 저렴한 PC에서 실행되는 공개 소프트웨어를 사용한다.
```
<br/>

### 조건부 GET
웹 캐싱이 사용자가 느끼는 응답 시간을 줄일 수 있지만, 캐시 내부의 객체 복사본이 최신 상태를 유지하지 못할 수도 있는 문제를 야기한다.<br/> 
다행히도, HTTP는 클라이언트가 브라우저로 전달되는 모든 객체가 최신의 것임을 확인하면서 캐싱을 하게 해주는 방식을 갖고 있다.<br/>
이러한 방식을 `조건부 GET(conditional GET)`이라고 한다.<br/>
<br/>

- `조건부 GET 메시지`
  - (1) GET 방식 사용
  - (2) If-Modified-Since: 헤더 라인 포함
<br/>

- 조건부 GET이 어떻게 동작하는지를 예시를 통해 알아보자.
<br/>

1. 브라우저의 요청을 대신해 프록시 캐시는 요청 메시지를 웹 서버로 보낸다.
```
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
```
<br/>

2. 웹 서버는 캐시에게 객체를 가진 응답 메시지를 보낸다.
```
HTTP/1.1 200 OK
Date: Sat, 3 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)
Last-Modified: Wed, 9 Sep 2015 09:23:24
Content-Type: image/gif
(data data data data data ...)
```
<br/>

> 💡 캐시는 요청하는 브라우저에게 객체를 보내주고 자신에게도 객체를 저장한다. 이 때, 마지막 수정 날짜를 포함
<br/>

3. 일주일 후에 다른 브라우저가 같은 객체를 캐시에게 요청하면 객체는 여전히 저장되어 있다. -> `조건부 GET`으로 갱신 조사 수행
```
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Wed, 9 Sep 2015 09:23:24
```
<br/>

> 💡 **If-modified-since:** 정확히 일치하는 것을 유의!<br/>
> 조건부 GET은 서버에게 그 객체가 명시된 날짜 이후 수정된 경우에만 그 객체를 보낼 것을 말하고 있다.
<br/>

4. 그 객체가 Wed, 9 Sep 2015 09:23:24 이후 변경되지 않았을 경우의 가정
```
HTTP/1.1 304 Not Modified
Date: Sat, 10 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)
(empty entity body)
```
<br/>

> 💡 데이터가 변화가 없어도 객체를 보내는 것은 대역폭을 낭비하는 것이고, 특히 그 개체가 크다면 사용자가 느끼는 응답 시간이 증가된다.<br/>
> 위 응답 메시지는 클라이언트에게 요청 객체의 캐싱된 복사본을 사용하라는 것을 의미
<br/>
<br/>

## 2.2.6 HTTP/2
2020년 기준 구글 크롬, 인터넷 익스플로러, 사파리, 파이어폭스 등을 포함하여 대부분 주요 브라우저들은 HTTP/2를 지원하고 있다.
<br/>

`HTTP/2의 주요 목표`는 하나의 TCP 연결상에서 멀티플렉싱 요청/응답 지연 시간을 줄이는 데 있으며,<br/>
요청 우선순위화, 서버 푸시, HTTP 헤더 필드의 효율적인 압축 기능 등을 제공한다.
<br/>

HTTP/2는 상태 코드, URL, 헤더 필드 등 메소드 자체는 변경하지 않고 데이터 포맷 방법과 전송 방법을 변경했다.<br/>

- 기존의 HTTP/1.1
  - 웹 페이지당 오직 하나의 TCP 연결을 갖는다.
  - 서버에서의 소켓 수를 줄이며 전송되는 각 웹 페이지는 공정한 네트워크 대역폭을 가질 수 있다.
  - 그러나 하나의 TCP 상에서 웹 페이지에 있는 모든 객체를 보내면 `HOL(Head of Line) 블로킹` 문제가 발생할 수 있다는 사실 확인
<br/>

### HOL 블로킹 문제
HTML 페이지, 웹 페이지 상단에 큰 비디오 클립, 비디오 아래 수많은 작은 객체들을 포함하는 하나의 웹 페이지를 고려해보자.<br/> 
또한, 서버와 클라이언트 사이에 저속에서 중간 속도의 병목 링크가 있다고 하자.
<br/>

- 비디오 클립은 병목 링크를 통과하는데 오래 걸리는 반면,
- 작은 객체들은 비디오 클립 뒤에서 기다림이 길어진다.<br/>

즉, 비디오 클립이 작은 객체들을 블로킹하게 된다.<br/>
HTTP/1.1에서는 여러 개의 병렬 TCP 연결을 열어서 HOL 블로킹 문제를 해결해왔다.<br/>
<br/>

### TCP 혼잡 제어
> 📌 TCP 혼잡 제어는 각 TCP 연결이 공정하게 병목 링크를 공유하여 같은 크기의 가용한 대역폭을 공평하게 나누게 해준다.<br/>

- 만일 n개의 TCP 연결이 병목 링크에서 작동하고 있다면, 각 연결은 대략 대역폭의 1/n 씩을 사용하게 된다.
- 웹 페이지를 전송하기 위해 여러 개의 병렬 TCP 연결을 열게 함으로써 브라우저는 일종의 속임수로 링크 대역폭의 많은 부분을 받게 된다.<br/>

`HTTP/2의 주요 목표` 중 하나는 하나의 웹 페이지를 전송하기 위한 병렬 TCP 연결의 수를 줄이거나 제거하는 데 있다.<br/>
<br/>

### HTTP/2 프레이밍
> 📌 HTTP/2는 각 메시지를 작은 프레임으로 나누고, 같은 TCP 연결에서의 요청과 응답 메시지를 인터리빙한다.<br/>

앞서 언급한 하나의 큰 비디오 클립과 8개의 작은 객체로 이루어진 웹 페이지의 예시<br/>
서버는 브라우저를 통해 9개의 병렬 요청을 받게 되고, 9개의 HTTP 응답 메시지를 보내야 한다.<br/>

- 가정
  - 모든 프레임은 고정된 길이를 갖는다.
  - 비디오 클립은 1000개의 프레임으로 구성되며, 작은 객체들은 2개의 프레임으로 구성된다.<br/>

비디오 클립, 객체 인터리빙을 이용하여 프레임을 전송하면 모든 소형 객체는 18개의 프레임이면 전송 완료된다.<br/>
만약 인터리빙이 사용되지 않았다면 소형 객체들은 1016개의 프레임이 보내진 후에야 전송될 것
<br/>

>💡HTTP 메시지를 독립된 프레임들로 쪼개고 인터리빙하고 반대편 사이트에서 재조립하는 것이야말로 가장 중요한 개선점
<br/>

`프레이밍`은 HTTP/2 프로토콜의 프레임으로 구현된 다른 서브 계층에 의해 이루어진다.<br/>
- **서버**가 HTTP 응답을 보내고자 할 때, **응답**은 프레이밍 서브 계층에 의해 처리되며 프레임들로 나눠진다.
- **응답의 헤더필드**는 하나의 프레임이 되고, 메시지 본문은 하나의 프레임으로 쪼개진다.
- **응답 프레임**들은 서버의 프레이밍 서브 계층에 의해 인터리빙된 후 하나의 지속적인 TCP 연결상에서 전송된다.
- 프레임들이 클라이언트에 도착하면 프레이밍 서브 계층에서 처음 응답메시지로 재조립되며 브라우저에 의해 처리된다.
<br/>

> 각 HTTP 메시지를 독립적인 프레임으로 쪼개는 것 외에도 프레이밍 서브 계층은 프레임을 바이너리 인코딩한다.<br/>
> 바이너리 프로토콜은 파싱하기에 효율적이고, 더 작은 프레임 크기를 갖고, 에러에 강하다.<br/>
<br/>

### 메시지 우선순위화 및 서버 푸싱
